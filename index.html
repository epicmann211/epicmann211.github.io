<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VR Music Game</title>
<style>
  body { margin: 0; overflow: hidden; }
  #info { position: absolute; top: 10px; left: 10px; color: white; font-weight: bold; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; z-index: 10;}
  #score { position: absolute; top: 10px; right: 10px; color: white; font-weight: bold; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px;}
</style>
</head>
<body>
<div id="info">VR: Enter VR | Hit cubes to score points!</div>
<div id="score">Score: 0</div>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<script>
const canvas = document.createElement("canvas");
document.body.appendChild(canvas);
const engine = new BABYLON.Engine(canvas, true);

let score = 0;
const scoreDiv = document.getElementById("score");

const createScene = async function() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.1,0.1,0.2);

    // Camera
    const camera = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0, 1.6, -5), scene);
    camera.attachControl(canvas, true);

    // Light
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:20, height:20}, scene);
    ground.material = new BABYLON.StandardMaterial("groundMat", scene);
    ground.material.diffuseColor = new BABYLON.Color3(0.05,0.05,0.1);

    // Music cubes
    const cubes = [];
    const colors = [BABYLON.Color3.Red(), BABYLON.Color3.Green(), BABYLON.Color3.Blue(), BABYLON.Color3.Yellow()];
    for(let i=0;i<10;i++){
        const cube = BABYLON.MeshBuilder.CreateBox("cube"+i, {size:0.5}, scene);
        cube.position = new BABYLON.Vector3(Math.random()*8-4,1 + Math.random()*2, Math.random()*8-4);
        const mat = new BABYLON.StandardMaterial("mat"+i, scene);
        mat.diffuseColor = colors[i % colors.length];
        cube.material = mat;
        cube.physicsImpostor = new BABYLON.PhysicsImpostor(cube, BABYLON.PhysicsImpostor.BoxImpostor, {mass:1, restitution:0.7}, scene);
        cubes.push(cube);
    }

    // Audio
    const music = new Audio("music.mp3");
    music.loop = true;
    music.volume = 0.5;
    music.play().catch(()=>console.log("Autoplay blocked"));

    // Enable physics
    scene.enablePhysics(new BABYLON.Vector3(0,-9.8,0), new BABYLON.CannonJSPlugin());

    // WebXR with hand models
    const xr = await scene.createDefaultXRExperienceAsync({floorMeshes:[ground], optionalFeatures:["hand-tracking"]});
    const xrInput = xr.input;

    xrInput.onControllerAddedObservable.add((controller)=>{
        if(controller.pointer){
            // Replace sphere with hand mesh
            const handMesh = BABYLON.MeshBuilder.CreateBox("handVisual", {size:0.15}, scene);
            handMesh.material = new BABYLON.StandardMaterial("handMat", scene);
            handMesh.material.diffuseColor = BABYLON.Color3.White();
            handMesh.parent = controller.pointer;

            controller.onMotionControllerInitObservable.add((motionController)=>{
                motionController.onButtonStateChangeObservable.add((button)=>{
                    if(button.pressed){
                        cubes.forEach(cube=>{
                            if(handMesh.intersectsMesh(cube,false)){
                                // Bounce cube
                                cube.physicsImpostor.applyImpulse(new BABYLON.Vector3(0,5,0), cube.getAbsolutePosition());
                                // Play sound
                                const beep = new Audio("music.mp3");
                                beep.currentTime = 0;
                                beep.play();
                                // Add score
                                score += 1;
                                scoreDiv.innerText = "Score: " + score;
                                // Visual feedback
                                cube.material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                            }
                        });
                    }
                });
            });
        }
    });

    // Move cubes slowly in a floating pattern
    scene.onBeforeRenderObservable.add(()=>{
        const dt = engine.getDeltaTime()/1000;
        cubes.forEach((cube, idx)=>{
            cube.position.y += Math.sin(Date.now()/500 + idx) * 0.002;
        });
    });

    return scene;
};

const scene = await createScene();
engine.runRenderLoop(()=> scene.render());
window.addEventListener('resize', ()=> engine.resize());
</script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
</body>
</html>
