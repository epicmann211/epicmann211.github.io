<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>WebXR Gorilla-Tag Style Arm Locomotion</title>
<style>
  body,html { margin:0; padding:0; overflow:hidden; background:#000; }
  canvas { width:100%; height:100%; display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js';

let scene, camera, renderer;
let player, leftHand, rightHand;
let armsTouchingGround = {left:false, right:false};
let prevLeftPos = null, prevRightPos = null;
let speed = 0.1;

init();

function init(){
    // Renderer & Scene
    renderer = new THREE.WebGLRenderer({canvas: document.getElementById('canvas'), antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(VRButton.createButton(renderer));

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,1.6,3);

    // Light
    const light = new THREE.HemisphereLight(0xffffff,0x444444,1);
    scene.add(light);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(20,20);
    const groundMat = new THREE.MeshStandardMaterial({color:0x333333});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // Player
    const bodyGeo = new THREE.CapsuleGeometry(0.35,1.0,4,8);
    const bodyMat = new THREE.MeshStandardMaterial({color:0x00ff00});
    player = new THREE.Mesh(bodyGeo, bodyMat);
    player.position.y = 1;
    scene.add(player);

    // Hands
    const handGeo = new THREE.SphereGeometry(0.15,16,16);
    const handMatL = new THREE.MeshStandardMaterial({color:0xff0000});
    const handMatR = new THREE.MeshStandardMaterial({color:0x0000ff});
    leftHand = new THREE.Mesh(handGeo, handMatL);
    rightHand = new THREE.Mesh(handGeo, handMatR);
    scene.add(leftHand);
    scene.add(rightHand);

    // Ground collision helper
    const handRaycaster = new THREE.Raycaster();

    renderer.setAnimationLoop(()=>{
        // VR controller positions
        const session = renderer.xr.getSession();
        if(session){
            const inputSources = session.inputSources;
            inputSources.forEach(src => {
                if(src.gripSpace){
                    const ref = renderer.xr.getReferenceSpace();
                    const pos = new THREE.Vector3();
                    const rot = new THREE.Quaternion();
                    const matrix = new Float32Array(16);
                    src.gripSpace.getOffsetReferenceSpace(ref).matrix.array.forEach((v,i)=>matrix[i]=v);
                    const m = new THREE.Matrix4().fromArray(matrix);
                    pos.setFromMatrixPosition(m);
                    if(src.handedness==='left'){ leftHand.position.copy(pos); }
                    else if(src.handedness==='right'){ rightHand.position.copy(pos); }
                }
            });
        }

        // Arm touch ground collision and movement
        [ ['left', leftHand, prevLeftPos], ['right', rightHand, prevRightPos] ].forEach(([handName, hand, prevPos])=>{
            handRaycaster.set(hand.position, new THREE.Vector3(0,-1,0));
            const intersects = handRaycaster.intersectObject(ground);
            const touching = intersects.length > 0 && intersects[0].distance <= 0.18;
            if(touching && prevPos){
                const delta = hand.position.clone().sub(prevPos);
                player.position.x += delta.x * speed;
                player.position.z += delta.z * speed;
            }
            if(handName==='left') prevLeftPos = hand.position.clone();
            else prevRightPos = hand.position.clone();
        });

        camera.position.x = player.position.x;
        camera.position.z = player.position.z;
        camera.position.y = player.position.y + 0.6;

        renderer.render(scene,camera);
    });
}
</script>
</body>
</html>
